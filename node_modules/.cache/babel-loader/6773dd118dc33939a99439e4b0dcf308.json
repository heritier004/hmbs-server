{"ast":null,"code":"var _classCallCheck = require(\"/Users/heritier/repos/github/hmbs-server/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/heritier/repos/github/hmbs-server/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\n/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar fs = require('fs');\n\nvar zlib = require('zlib');\n\nmodule.exports = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function PNG(data) {\n    _classCallCheck(this, PNG);\n\n    var i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var chunkSize = this.readUInt32();\n      var section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  _createClass(PNG, [{\n    key: \"read\",\n    value: function read(bytes) {\n      var result = new Array(bytes);\n\n      for (var i = 0; i < bytes; i++) {\n        result[i] = this.data[this.pos++];\n      }\n\n      return result;\n    }\n  }, {\n    key: \"readUInt32\",\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: \"readUInt16\",\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: \"decodePixels\",\n    value: function decodePixels(fn) {\n      var _this = this;\n\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n\n        var width = _this.width,\n            height = _this.height;\n        var pixelBytes = _this.pixelBitlength / 8;\n        var pixels = new Buffer(width * height * pixelBytes);\n        var length = data.length;\n        var pos = 0;\n\n        function pass(x0, y0, dx, dy) {\n          var singlePass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n          var w = Math.ceil((width - x0) / dx);\n          var h = Math.ceil((height - y0) / dy);\n          var scanlineLength = pixelBytes * w;\n          var buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n          var row = 0;\n          var c = 0;\n\n          while (row < h && pos < length) {\n            var byte, col, i, left, upper;\n\n            switch (data[pos++]) {\n              case 0:\n                // None\n                for (i = 0; i < scanlineLength; i++) {\n                  buffer[c++] = data[pos++];\n                }\n\n                break;\n\n              case 1:\n                // Sub\n                for (i = 0; i < scanlineLength; i++) {\n                  byte = data[pos++];\n                  left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                  buffer[c++] = (byte + left) % 256;\n                }\n\n                break;\n\n              case 2:\n                // Up\n                for (i = 0; i < scanlineLength; i++) {\n                  byte = data[pos++];\n                  col = (i - i % pixelBytes) / pixelBytes;\n                  upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  buffer[c++] = (upper + byte) % 256;\n                }\n\n                break;\n\n              case 3:\n                // Average\n                for (i = 0; i < scanlineLength; i++) {\n                  byte = data[pos++];\n                  col = (i - i % pixelBytes) / pixelBytes;\n                  left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                  upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n                }\n\n                break;\n\n              case 4:\n                // Paeth\n                for (i = 0; i < scanlineLength; i++) {\n                  var paeth, upperLeft;\n                  byte = data[pos++];\n                  col = (i - i % pixelBytes) / pixelBytes;\n                  left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                  if (row === 0) {\n                    upper = upperLeft = 0;\n                  } else {\n                    upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                    upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                  }\n\n                  var p = left + upper - upperLeft;\n                  var pa = Math.abs(p - left);\n                  var pb = Math.abs(p - upper);\n                  var pc = Math.abs(p - upperLeft);\n\n                  if (pa <= pb && pa <= pc) {\n                    paeth = left;\n                  } else if (pb <= pc) {\n                    paeth = upper;\n                  } else {\n                    paeth = upperLeft;\n                  }\n\n                  buffer[c++] = (byte + paeth) % 256;\n                }\n\n                break;\n\n              default:\n                throw new Error(\"Invalid filter algorithm: \".concat(data[pos - 1]));\n            }\n\n            if (!singlePass) {\n              var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n              var bufferPos = row * scanlineLength;\n\n              for (i = 0; i < w; i++) {\n                for (var j = 0; j < pixelBytes; j++) {\n                  pixels[pixelsPos++] = buffer[bufferPos++];\n                }\n\n                pixelsPos += (dx - 1) * pixelBytes;\n              }\n            }\n\n            row++;\n          }\n        }\n\n        if (_this.interlaceMethod === 1) {\n          /*\n            1 6 4 6 2 6 4 6\n            7 7 7 7 7 7 7 7\n            5 6 5 6 5 6 5 6\n            7 7 7 7 7 7 7 7\n            3 6 4 6 3 6 4 6\n            7 7 7 7 7 7 7 7\n            5 6 5 6 5 6 5 6\n            7 7 7 7 7 7 7 7\n          */\n          pass(0, 0, 8, 8); // 1\n\n          pass(4, 0, 8, 8); // 2\n\n          pass(0, 4, 4, 8); // 3\n\n          pass(2, 0, 4, 4); // 4\n\n          pass(0, 2, 2, 4); // 5\n\n          pass(1, 0, 2, 2); // 6\n\n          pass(0, 1, 1, 2); // 7\n        } else {\n          pass(0, 0, 1, 1, true);\n        }\n\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: \"decodePalette\",\n    value: function decodePalette() {\n      var palette = this.palette;\n      var length = palette.length;\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + length);\n      var pos = 0;\n      var c = 0;\n\n      for (var i = 0; i < length; i += 3) {\n        var left;\n        ret[pos++] = palette[i];\n        ret[pos++] = palette[i + 1];\n        ret[pos++] = palette[i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"copyToImageData\",\n    value: function copyToImageData(imageData, pixels) {\n      var j, k;\n      var colors = this.colors;\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n        colors = 4;\n        alpha = true;\n      }\n\n      var data = imageData.data || imageData;\n      var length = data.length;\n      var input = palette || pixels;\n      var i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(fn) {\n      var _this2 = this;\n\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this2.copyToImageData(ret, pixels);\n\n        return fn(ret);\n      });\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(path, fn) {\n      return fs.readFile(path, function (err, file) {\n        var png = new PNG(file);\n        return png.decode(function (pixels) {\n          return fn(pixels);\n        });\n      });\n    }\n  }, {\n    key: \"load\",\n    value: function load(path) {\n      var file = fs.readFileSync(path);\n      return new PNG(file);\n    }\n  }]);\n\n  return PNG;\n}();","map":{"version":3,"names":["fs","require","zlib","module","exports","data","i","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","Error","bytes","result","Array","b1","b2","b3","b4","fn","inflate","err","pixelBytes","pixels","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","ret","imageData","k","alpha","_decodedPalette","decodePalette","input","v","decodePixels","copyToImageData","path","readFile","file","png","PNG","decode","readFileSync"],"sources":["/Users/heritier/repos/github/hmbs-server/node_modules/png-js/png-node.js"],"sourcesContent":["/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}