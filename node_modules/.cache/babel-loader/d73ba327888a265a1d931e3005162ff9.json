{"ast":null,"code":"/* eslint no-console: 0 */\n'use strict';\n\nvar urllib = require('url');\n\nvar util = require('util');\n\nvar fs = require('fs');\n\nvar nmfetch = require('../fetch');\n\nvar dns = require('dns');\n\nvar net = require('net');\n\nvar os = require('os');\n\nvar DNS_TTL = 5 * 60 * 1000;\nvar networkInterfaces;\n\ntry {\n  networkInterfaces = os.networkInterfaces();\n} catch (err) {// fails on some systems\n}\n\nmodule.exports.networkInterfaces = networkInterfaces;\n\nvar isFamilySupported = function isFamilySupported(family, allowInternal) {\n  var networkInterfaces = module.exports.networkInterfaces;\n\n  if (!networkInterfaces) {\n    // hope for the best\n    return true;\n  }\n\n  var familySupported = // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n  Object.keys(networkInterfaces).map(function (key) {\n    return networkInterfaces[key];\n  }) // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n  .reduce(function (acc, val) {\n    return acc.concat(val);\n  }, []).filter(function (i) {\n    return !i.internal || allowInternal;\n  }).filter(function (i) {\n    return i.family === 'IPv' + family || i.family === family;\n  }).length > 0;\n  return familySupported;\n};\n\nvar resolver = function resolver(family, hostname, options, callback) {\n  options = options || {};\n  var familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n\n  if (!familySupported) {\n    return callback(null, []);\n  }\n\n  dns['resolve' + family](hostname, function (err, addresses) {\n    if (err) {\n      switch (err.code) {\n        case dns.NODATA:\n        case dns.NOTFOUND:\n        case dns.NOTIMP:\n        case dns.SERVFAIL:\n        case dns.CONNREFUSED:\n        case 'EAI_AGAIN':\n          return callback(null, []);\n      }\n\n      return callback(err);\n    }\n\n    return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n  });\n};\n\nvar dnsCache = module.exports.dnsCache = new Map();\n\nvar formatDNSValue = function formatDNSValue(value, extra) {\n  if (!value) {\n    return Object.assign({}, extra || {});\n  }\n\n  return Object.assign({\n    servername: value.servername,\n    host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n  }, extra || {});\n};\n\nmodule.exports.resolveHostname = function (options, callback) {\n  options = options || {};\n\n  if (!options.host && options.servername) {\n    options.host = options.servername;\n  }\n\n  if (!options.host || net.isIP(options.host)) {\n    // nothing to do here\n    var value = {\n      addresses: [options.host],\n      servername: options.servername || false\n    };\n    return callback(null, formatDNSValue(value, {\n      cached: false\n    }));\n  }\n\n  var cached;\n\n  if (dnsCache.has(options.host)) {\n    cached = dnsCache.get(options.host);\n\n    if (!cached.expires || cached.expires >= Date.now()) {\n      return callback(null, formatDNSValue(cached.value, {\n        cached: true\n      }));\n    }\n  }\n\n  resolver(4, options.host, options, function (err, addresses) {\n    if (err) {\n      if (cached) {\n        // ignore error, use expired value\n        return callback(null, formatDNSValue(cached.value, {\n          cached: true,\n          error: err\n        }));\n      }\n\n      return callback(err);\n    }\n\n    if (addresses && addresses.length) {\n      var _value = {\n        addresses: addresses,\n        servername: options.servername || options.host\n      };\n      dnsCache.set(options.host, {\n        value: _value,\n        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n      });\n      return callback(null, formatDNSValue(_value, {\n        cached: false\n      }));\n    }\n\n    resolver(6, options.host, options, function (err, addresses) {\n      if (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n\n        return callback(err);\n      }\n\n      if (addresses && addresses.length) {\n        var _value2 = {\n          addresses: addresses,\n          servername: options.servername || options.host\n        };\n        dnsCache.set(options.host, {\n          value: _value2,\n          expires: Date.now() + (options.dnsTtl || DNS_TTL)\n        });\n        return callback(null, formatDNSValue(_value2, {\n          cached: false\n        }));\n      }\n\n      try {\n        dns.lookup(options.host, {\n          all: true\n        }, function (err, addresses) {\n          if (err) {\n            if (cached) {\n              // ignore error, use expired value\n              return callback(null, formatDNSValue(cached.value, {\n                cached: true,\n                error: err\n              }));\n            }\n\n            return callback(err);\n          }\n\n          var address = addresses ? addresses.filter(function (addr) {\n            return isFamilySupported(addr.family);\n          }).map(function (addr) {\n            return addr.address;\n          }).shift() : false;\n\n          if (addresses && addresses.length && !address) {\n            // there are addresses but none can be used\n            var _err = new Error(\"Can not use IPv\".concat(addresses[0].family, \" addresses with current network\"));\n\n            return callback(_err);\n          }\n\n          if (!address && cached) {\n            // nothing was found, fallback to cached value\n            return callback(null, formatDNSValue(cached.value, {\n              cached: true\n            }));\n          }\n\n          var value = {\n            addresses: address ? [address] : [options.host],\n            servername: options.servername || options.host\n          };\n          dnsCache.set(options.host, {\n            value: value,\n            expires: Date.now() + (options.dnsTtl || DNS_TTL)\n          });\n          return callback(null, formatDNSValue(value, {\n            cached: false\n          }));\n        });\n      } catch (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n\n        return callback(err);\n      }\n    });\n  });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\n\n\nmodule.exports.parseConnectionUrl = function (str) {\n  str = str || '';\n  var options = {};\n  [urllib.parse(str, true)].forEach(function (url) {\n    var auth;\n\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n\n      case 'smtps:':\n        options.secure = true;\n        break;\n\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n\n    if (url.auth) {\n      auth = url.auth.split(':');\n\n      if (!options.auth) {\n        options.auth = {};\n      }\n\n      options.auth.user = auth.shift();\n      options.auth.pass = auth.join(':');\n    }\n\n    Object.keys(url.query || {}).forEach(function (key) {\n      var obj = options;\n      var lKey = key;\n      var value = url.query[key];\n\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n\n        case 'false':\n          value = false;\n          break;\n      } // tls is nested object\n\n\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n\n        if (!options.tls) {\n          options.tls = {};\n        }\n\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\n\nmodule.exports._logFunc = function (logger, level, defaults, data, message) {\n  var entry = {};\n  Object.keys(defaults || {}).forEach(function (key) {\n    if (key !== 'level') {\n      entry[key] = defaults[key];\n    }\n  });\n  Object.keys(data || {}).forEach(function (key) {\n    if (key !== 'level') {\n      entry[key] = data[key];\n    }\n  });\n\n  for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    args[_key - 5] = arguments[_key];\n  }\n\n  logger[level].apply(logger, [entry, message].concat(args));\n};\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\n\n\nmodule.exports.getLogger = function (options, defaults) {\n  options = options || {};\n  var response = {};\n  var levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n  if (!options.logger) {\n    // use vanity logger\n    levels.forEach(function (level) {\n      response[level] = function () {\n        return false;\n      };\n    });\n    return response;\n  }\n\n  var logger = options.logger;\n\n  if (options.logger === true) {\n    // create console logger\n    logger = createDefaultLogger(levels);\n  }\n\n  levels.forEach(function (level) {\n    response[level] = function (data, message) {\n      var _module$exports;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      (_module$exports = module.exports)._logFunc.apply(_module$exports, [logger, level, defaults, data, message].concat(args));\n    };\n  });\n  return response;\n};\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\n\n\nmodule.exports.callbackPromise = function (resolve, reject) {\n  return function () {\n    var args = Array.from(arguments);\n    var err = args.shift();\n\n    if (err) {\n      reject(err);\n    } else {\n      resolve.apply(void 0, args);\n    }\n  };\n};\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nmodule.exports.resolveContent = function (data, key, callback) {\n  var promise;\n\n  if (!callback) {\n    promise = new Promise(function (resolve, reject) {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n\n  var content = data && data[key] && data[key].content || data[key];\n  var contentStream;\n  var encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n  if (!content) {\n    return callback(null, content);\n  }\n\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, function (err, value) {\n        if (err) {\n          return callback(err);\n        } // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n\n\n        if (data[key].content) {\n          data[key].content = value;\n        } else {\n          data[key] = value;\n        }\n\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = nmfetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      var parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return callback(null, Buffer.from(0));\n      }\n\n      return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n\n  if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n    content = Buffer.from(data[key].content, encoding);\n  } // default action, return as is\n\n\n  setImmediate(function () {\n    return callback(null, content);\n  });\n  return promise;\n};\n/**\n * Copies properties from source objects to target objects\n */\n\n\nmodule.exports.assign = function\n  /* target, ... sources */\n() {\n  var args = Array.from(arguments);\n  var target = args.shift() || {};\n  args.forEach(function (source) {\n    Object.keys(source || {}).forEach(function (key) {\n      if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // ensure that target has this key\n          target[key] = {};\n        }\n\n        Object.keys(source[key]).forEach(function (subKey) {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n};\n\nmodule.exports.encodeXText = function (str) {\n  // ! 0x21\n  // + 0x2B\n  // = 0x3D\n  // ~ 0x7E\n  if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n    return str;\n  }\n\n  var buf = Buffer.from(str);\n  var result = '';\n\n  for (var i = 0, len = buf.length; i < len; i++) {\n    var c = buf[i];\n\n    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n      result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n    } else {\n      result += String.fromCharCode(c);\n    }\n  }\n\n  return result;\n};\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\n\n\nfunction resolveStream(stream, callback) {\n  var responded = false;\n  var chunks = [];\n  var chunklen = 0;\n  stream.on('error', function (err) {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', function () {\n    var chunk;\n\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', function () {\n    if (responded) {\n      return;\n    }\n\n    responded = true;\n    var value;\n\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n\n    callback(null, value);\n  });\n}\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\n\n\nfunction createDefaultLogger(levels) {\n  var levelMaxLen = 0;\n  var levelNames = new Map();\n  levels.forEach(function (level) {\n    if (level.length > levelMaxLen) {\n      levelMaxLen = level.length;\n    }\n  });\n  levels.forEach(function (level) {\n    var levelName = level.toUpperCase();\n\n    if (levelName.length < levelMaxLen) {\n      levelName += ' '.repeat(levelMaxLen - levelName.length);\n    }\n\n    levelNames.set(level, levelName);\n  });\n\n  var print = function print(level, entry, message) {\n    var prefix = '';\n\n    if (entry) {\n      if (entry.tnx === 'server') {\n        prefix = 'S: ';\n      } else if (entry.tnx === 'client') {\n        prefix = 'C: ';\n      }\n\n      if (entry.sid) {\n        prefix = '[' + entry.sid + '] ' + prefix;\n      }\n\n      if (entry.cid) {\n        prefix = '[#' + entry.cid + '] ' + prefix;\n      }\n    }\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      args[_key3 - 3] = arguments[_key3];\n    }\n\n    message = util.format.apply(util, [message].concat(args));\n    message.split(/\\r?\\n/).forEach(function (line) {\n      console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n    });\n  };\n\n  var logger = {};\n  levels.forEach(function (level) {\n    logger[level] = print.bind(null, level);\n  });\n  return logger;\n}","map":{"version":3,"names":["urllib","require","util","fs","nmfetch","dns","net","os","DNS_TTL","networkInterfaces","err","module","exports","isFamilySupported","family","allowInternal","familySupported","Object","keys","map","key","reduce","acc","val","concat","filter","i","internal","length","resolver","hostname","options","callback","allowInternalNetworkInterfaces","addresses","code","NODATA","NOTFOUND","NOTIMP","SERVFAIL","CONNREFUSED","Array","isArray","dnsCache","Map","formatDNSValue","value","extra","assign","servername","host","Math","floor","random","resolveHostname","isIP","cached","has","get","expires","Date","now","error","set","dnsTtl","lookup","all","address","addr","shift","Error","parseConnectionUrl","str","parse","forEach","url","auth","protocol","secure","direct","isNaN","port","Number","split","user","pass","join","query","obj","lKey","indexOf","substr","tls","_logFunc","logger","level","defaults","data","message","entry","args","getLogger","response","levels","createDefaultLogger","callbackPromise","resolve","reject","from","arguments","resolveContent","promise","Promise","content","contentStream","encoding","toString","toLowerCase","replace","pipe","resolveStream","test","path","href","parts","match","Buffer","decodeURIComponent","createReadStream","includes","setImmediate","target","source","subKey","encodeXText","buf","result","len","c","toUpperCase","String","fromCharCode","stream","responded","chunks","chunklen","on","chunk","read","push","E","levelMaxLen","levelNames","levelName","repeat","print","prefix","tnx","sid","cid","format","line","console","log","toISOString","bind"],"sources":["/Users/heritier/repos/github/hmbs-server/node_modules/nodemailer/lib/shared/index.js"],"sourcesContent":["/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst nmfetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\nconst os = require('os');\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nlet networkInterfaces;\ntry {\n    networkInterfaces = os.networkInterfaces();\n} catch (err) {\n    // fails on some systems\n}\n\nmodule.exports.networkInterfaces = networkInterfaces;\n\nconst isFamilySupported = (family, allowInternal) => {\n    let networkInterfaces = module.exports.networkInterfaces;\n    if (!networkInterfaces) {\n        // hope for the best\n        return true;\n    }\n\n    const familySupported =\n        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n        Object.keys(networkInterfaces)\n            .map(key => networkInterfaces[key])\n            // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n            .reduce((acc, val) => acc.concat(val), [])\n            .filter(i => !i.internal || allowInternal)\n            .filter(i => i.family === 'IPv' + family || i.family === family).length > 0;\n\n    return familySupported;\n};\n\nconst resolver = (family, hostname, options, callback) => {\n    options = options || {};\n    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n\n    if (!familySupported) {\n        return callback(null, []);\n    }\n\n    dns['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\n\nconst formatDNSValue = (value, extra) => {\n    if (!value) {\n        return Object.assign({}, extra || {});\n    }\n\n    return Object.assign(\n        {\n            servername: value.servername,\n            host:\n                !value.addresses || !value.addresses.length\n                    ? null\n                    : value.addresses.length === 1\n                    ? value.addresses[0]\n                    : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n        },\n        extra || {}\n    );\n};\n\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host && options.servername) {\n        options.host = options.servername;\n    }\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            addresses: [options.host],\n            servername: options.servername || false\n        };\n        return callback(\n            null,\n            formatDNSValue(value, {\n                cached: false\n            })\n        );\n    }\n\n    let cached;\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n\n        if (!cached.expires || cached.expires >= Date.now()) {\n            return callback(\n                null,\n                formatDNSValue(cached.value, {\n                    cached: true\n                })\n            );\n        }\n    }\n\n    resolver(4, options.host, options, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                // ignore error, use expired value\n                return callback(\n                    null,\n                    formatDNSValue(cached.value, {\n                        cached: true,\n                        error: err\n                    })\n                );\n            }\n            return callback(err);\n        }\n\n        if (addresses && addresses.length) {\n            let value = {\n                addresses,\n                servername: options.servername || options.host\n            };\n\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + (options.dnsTtl || DNS_TTL)\n            });\n\n            return callback(\n                null,\n                formatDNSValue(value, {\n                    cached: false\n                })\n            );\n        }\n\n        resolver(6, options.host, options, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n\n            if (addresses && addresses.length) {\n                let value = {\n                    addresses,\n                    servername: options.servername || options.host\n                };\n\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                });\n\n                return callback(\n                    null,\n                    formatDNSValue(value, {\n                        cached: false\n                    })\n                );\n            }\n\n            try {\n                dns.lookup(options.host, { all: true }, (err, addresses) => {\n                    if (err) {\n                        if (cached) {\n                            // ignore error, use expired value\n                            return callback(\n                                null,\n                                formatDNSValue(cached.value, {\n                                    cached: true,\n                                    error: err\n                                })\n                            );\n                        }\n                        return callback(err);\n                    }\n\n                    let address = addresses\n                        ? addresses\n                              .filter(addr => isFamilySupported(addr.family))\n                              .map(addr => addr.address)\n                              .shift()\n                        : false;\n\n                    if (addresses && addresses.length && !address) {\n                        // there are addresses but none can be used\n                        let err = new Error(`Can not use IPv${addresses[0].family} addresses with current network`);\n                        return callback(err);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(\n                            null,\n                            formatDNSValue(cached.value, {\n                                cached: true\n                            })\n                        );\n                    }\n\n                    let value = {\n                        addresses: address ? [address] : [options.host],\n                        servername: options.servername || options.host\n                    };\n\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                    });\n\n                    return callback(\n                        null,\n                        formatDNSValue(value, {\n                            cached: false\n                        })\n                    );\n                });\n            } catch (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function () {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                if (data[key].content) {\n                    data[key].content = value;\n                } else {\n                    data[key] = value;\n                }\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = nmfetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n            if (!parts) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function (/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}